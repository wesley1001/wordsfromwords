
When navigation to EmailSetPasswordView occurs:

    EmailSetPasswordView renders:

        - A gorgeous background of some kind (same as LoadingView?)

        - An input (with 'placeholder' set to 'Password' and 'secureTextEntry' set to true)

        - An input (with 'placeholder' set to 'Confirm Password' and 'secureTextEntry' set to true)

        - A switch component with label 'Show Passwords'

        - A 'Submit' button

    User action occurs:

        if (the user types password1) {

            EmailSetPasswordView saves it (onChangeText) to EmailLoginModel

        }

        if (the user types the password2) {

            EmailSetPasswordView saves it (onChangeText) to EmailLoginModel

        }

        if (the user toggles the switch) {

            EmailSetPasswordView calls setState({secure: false}) which causes a re-render with non 'secureTextEntry' inputs

        }

        if (the user taps the 'Submit' button) {

            EmailSetPasswordView notifies EmailLoginModel

            EmailLoginModel validates the passwords:

                if (password1.length < 8) {

                    EmailLoginModel calls back to EmailSetPasswordView with {reason: 'invalid'}

                    EmailSetPasswordView displays an alert:

                        'Too short...'

                        'I find your lack of security disturbing (passwords must be at least 8 characters).'

                        [OK]

                } else if (password1 !== password2) {

                    EmailLoginModel calls back to EmailSetPasswordView with {reason: 'mismatch'}

                    EmailSetPasswordView displays an alert:

                        'Typo...'

                        'Your passwords don't match.'

                        [OK]

                } else {

                    EmailLoginModel POSTs uuid, passwords to /api/email/passwords

                    /api/email/passwords looks up user WHERE uuid = uuid

                    if (user !== null) {

                        /api/email/passwords does the following:

                            hashes the new password

                            generates a new email_token

                            generates a new email_token_exp

                            UPDATEs password, email_token, and email_token_exp

                            returns a 200 response (OK) with {uuid: uuid, stored_token: email_token}

                            EmailLoginModel sets uuid and stored_token on GlobalModel

                            EmailLoginModel writes uuid and stored_token via AsyncStorage

                            EmailLoginModel navigates (via something that replaces all routes?) to GameListView

                            --->

                    } else {

                        /api/email/passwords returns a 400 response (Bad Request)

                    }

                }

        }



















